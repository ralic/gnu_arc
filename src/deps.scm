;;  This file is part of the arc package
;;  Copyright (C) 2002, 2003, 2009 by Gregor Klinke
;;
;;  This library is free software: you can redistribute it and/or modify
;;  it under the terms of the GNU Lesser General Public License as published
;;  by the Free Software Foundation, either version 3 of the License, or
;;  (at your option) any later version.
;;
;;  This library is distributed in the hope that it will be useful,
;;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;;  GNU Lesser General Public License for more details.
;;
;;  You should have received a copy of the GNU General Public License
;;  along with this program.  If not, see <http://www.gnu.org/licenses/>.

;; ----------------------------------------------------------------------
;; generic dependency support.
;;
;; most languages will use a (language) specific dependecy support, but
;; some functionality is supported by allmost all languages.
;;
;; this functions load and save (arc specific) dependency files, whereas
;; the language specific construction and setup of dependency files is
;; implementented in the appropriate task-*-deps.scm file
;;
;; the format of the dependency list: it returns a list with two elements,
;; the first is the target (in the makefile notation), and the second is an
;; list of cons'.  Each cons in the list have in its car the dependencie's
;; name and in the cdr the modification time
;;
;; example:
;; ("target.o" (("target.c" . 0) ("../include/types.h" . 0) 
;;    ("../include/gc.h" . 0)))
;; ----------------------------------------------------------------------

;; the directory where to put dependency files
;(define %arc:deps-directory% ".arc/deps")

;(arc:register-built-resource ".arc" 'recursive)

(define %arc:deps-mode% 'database)

;; returns the dependency directory as a path object
(define (arc:deps-directory)
  (arc:builddir "deps"))

(define (arc:deps? deps)
  (and deps
       (list? deps)))

;; creates a new dependency object for the target file ofile
(define (arc:make-deps ofile . deps)
  (let* ((retv (list ofile '())))
    (if (not (null? deps))
        (let loop ((d (car deps)))
          (if (null? d)
              retv
              (begin
                (arc:deps-set-deps! retv (car d))
                (loop (cdr d)))))
        retv)))

;; sets a dependency for file /dfile/ to a dependency object.  Returns the
;; updated deps object
(define (arc:deps-set-deps! deps dfile)
  (let* ((aslot (assoc dfile (cadr deps))))
    (if (not aslot)
        (set-cdr! deps (list (append (cadr deps)
                                     (list (cons dfile 0))))))
    deps))
  
;; sets the target object /sfile/ of a dependency; returns the updated deps
;; object
(define (arc:deps-set-target! deps sfile)
  (set-car! deps sfile)
  deps)

(define (arc:deps-target deps)
  (car deps))

(define (arc:deps-number-of-dependencies deps)
  (if (list? deps)
      (length (cdr deps))
      0))

;; checkes whether /dfile/ is listed in /deps/ object as dependency
(define (arc:deps-is-in-deps? deps dfile)
  (assoc dfile (cadr deps)))


;; creates a unified file name for a source name
(define (arc:deps-file-name fn)
  (let* ((fnp (arc:string->path fn))
         (fnbn (arc:path-append-ext fnp "P"))
         (dfn (arc:path-append (arc:deps-directory)
                               (arc:deps-flatten-file-name fnbn))))
    (arc:path->string dfn)))

;; makes a path 'flat': that means concats the path steps with %2d (=/)
;; into a string, so the path can be used for a single file name
(define (arc:deps-flatten-file-name fn)
  (let ((x (arc:reduce (lambda (elt lst)
                         (if (equal? elt "/")
                             (cons "%2f" lst)
                             (cons "%2d" (cons elt lst))) )
                       '()
                       fn)))
    (arc:string-list->string x)))

(define (arc:load-deps-file fn)
  (if (sys:file-exists? fn)
      (let* ((port (open-input-file fn))
             (deps (read port)))
        (close-input-port port)
        deps)
      #f))

(define (arc:save-deps-file fn deps)
  (if (sys:file-exists? fn)
      (sys:remove-file fn))
  (let ((port (open-output-file fn)))
    ;; produce some informational stuff
    (display ";; don't edit this file" port) (newline port)
    (display ";; automatic created by arc vr " port) 
    (display %arc:version% port) (newline port)
    ;; write the real dependency thing
    (write deps port)
    (close-output-port port)))


;; ----------------------------------------------------------------------
;; file mtime stuff
;; ----------------------------------------------------------------------
;; walks on a dependency list as generated by parse-c-deps-file and fills
;; in the modification times in the deps cons'
(define (arc:deps-determine-mtime deps)
  (for-each (lambda (fc)
              (set-cdr! fc (sys:mtime (car fc))) )
            (cadr deps))
  deps)

(define (arc:deps-update-mtimes deps)
  (arc:deps-determine-mtime deps)
  (arc:deps-set-dirty-handler))


;; Indicates whether the mtime (modification time) flag of any dependency
;; for //ofile// has changed as passed in as //deps//.  The mtime slots in
;; //deps// are updated to the real mtime values from the file system.
(define (arc:mtime-file-changed? deps ofile)
  (let ((retv (let ((mtime (sys:mtime ofile))
                    (dps (arc:deps-determine-mtime deps)))
                (if (not mtime)
                    #t
                    (let loop ((fc (cadr dps)))
                      (if (null? fc)
                          #f
                          (or (not (cdar fc))
                              (< mtime (cdar fc))
                              (loop (cdr fc))) ))))) )
    (arc:log 'debug "mtime changed of " ofile " -> " retv)
    retv))
      
;; return the mtime for a dependency file //dfile// from the dependency
;; list //deps//.  Returns #f if the file is not in the list
(define (arc:deps-mtime deps dfile)
  (let loop ((fc (cadr deps)))
    (if (null? fc)
        #f
        (if (equal? (caar fc) dfile)
            (cdar fc)
            (loop (cdr fc))) )))
            

;; ----------------------------------------------------------------------
;; find and update the dependency
;; ----------------------------------------------------------------------
;; loads the dependencies of a target file ofile.  If no such dependencies
;; set is found (=has not been generated yet), it calls the function /proc/
;; with two arguments: sfile (=the source file) and ofile (=the target file).
;; The function is expected to return a valid deps object or #f if the 
;; the dependency couldn't be computed.
(define (arc:deps-get-deps sfile ofile proc)
  (case %arc:deps-mode%
    ((sep-files) (arc:deps-get-deps-single-file sfile ofile proc))
    ((database) (arc:deps-get-deps-database sfile ofile proc))
    (else
     #f)))

(define (arc:deps-update-deps ofile deps)
  (case %arc:deps-mode%
    ((sep-files) (arc:deps-update-deps-single-file ofile deps))
    ((database) (arc:deps-update-deps-database ofile deps))
    (else
     #f)))

;; ----------------------------------------------------------------------
;; store the dependencies in one dependency file pro source file
;; ----------------------------------------------------------------------
(define (arc:deps-get-deps-single-file sfile ofile proc)
  (let* ((fn (arc:deps-file-name ofile))
         (df (arc:load-deps-file fn)))
    (if (not df)
        (let* ((deps (apply proc (list sfile ofile))))
          (if (and deps
                   (arc:deps? deps))
              (arc:save-deps-file fn deps))
          deps)
        df)))

(define (arc:deps-update-deps-single-file ofile deps)
  (let* ((fn (arc:deps-file-name ofile)))
    (arc:save-deps-file fn deps)))


;; ----------------------------------------------------------------------
;; store the dependencies in one single database file
;; to achive acceptable performance on large projects (i.e. having many
;; source files), we're using a hash-table here.
;; ----------------------------------------------------------------------
(define %arc:deps-database% 'unloaded)
(define %arc:deps-database-dirty-handler% #f)
(define arc:deps-db-associator #f)
(define arc:deps-db-inquirer #f)
(define %arc:deps-database-size% 1024)

(define (arc:deps-db-file-name)
  (arc:path->string (arc:path-append (arc:deps-directory)
                                     "deps.db")))

(define (arc:deps-db-load-db dbn)
  (if (equal? %arc:deps-database% 'unloaded)
      (begin
        (set! %arc:deps-database% (or (arc:load-deps-file dbn)
                                      (make-hash-table %arc:deps-database-size%)))
        (set! arc:deps-db-associator (hash-associator equal?))
        (set! arc:deps-db-inquirer (hash-inquirer equal?)))))

(define (arc:deps-set-dirty-handler)
  (set! %arc:deps-database-dirty-handler%
        (lambda ()
          (arc:save-deps-file (arc:deps-db-file-name) %arc:deps-database%))))
  
(define (arc:deps-db-set-deps! deps)
  (let ((dbn (arc:deps-db-file-name)))
    (arc:deps-db-load-db dbn)
 
    (let* ((key (arc:deps-target deps)))
      (arc:deps-db-associator %arc:deps-database% key deps)
      (arc:deps-set-dirty-handler))))
            

(define (arc:deps-db-get-deps key)
  (let ((dbn (arc:deps-db-file-name)))
    (arc:deps-db-load-db dbn)
    (arc:deps-db-inquirer %arc:deps-database% key)
    ))


(define (arc:deps-get-deps-database sfile ofile proc)
  (let* ((df (arc:deps-db-get-deps ofile)))
    (if (not df)
        (let* ((deps (apply proc (list sfile ofile))))
          (if (and deps
                   (arc:deps? deps))
              (arc:deps-db-set-deps! deps))
          deps)
        df)))

(define (arc:deps-update-deps-database ofile deps)
  (arc:deps-db-set-deps! deps))

(define (arc:deps-store-database)
  (if (procedure? %arc:deps-database-dirty-handler%)
      (apply %arc:deps-database-dirty-handler% '())))




;; ----------------------------------------------------------------------
;; parsing dependency files as generated by makedeps
;; ----------------------------------------------------------------------

;; parses a dependency file as generate by a c compile and prepared for
;; Makefiles.  These files have the format:
;;
;; target.o: depc.c dep2.h dep3.h \
;;   dep4.h dep5.h dep6.h dep7.h \
;;   dep8.h
;;
;; it returns a list, its first element is the target (in the makefile
;; notation), and its second is an list of cons'.  Each cons in the list
;; have in its car the dependencie's name and in the cdr a zero (this is to
;; take the modification time later)
(define (arc:parse-make-deps-file fn)
  (let* ((port (open-input-file fn))
         (state 'pre-ws)
         (buf '())
         (deps (arc:make-deps ""))
         )
    (do ((c (read-char port) (read-char port)))
        ((eof-object? c) #t)
      (case state
        ((pre-ws) (case c
                    ((#\space #\newline #\tab #\return) 'ignore)
                    (else (begin
                            (set! state 'targ)
                            (set! buf (cons c buf))))))
        ((targ) (case c
                  ((#\:) (begin
                           (set! state 'targ-ws)
                           (arc:deps-set-target! deps 
                                                 (list->string (reverse buf)))
                           (set! buf '())))
                  (else (set! buf (cons c buf)))))
        ((targ-ws) (case c
                     ((#\space #\newline #\tab #\return) 'ignore)
                     (else (begin 
                             (set! state 'dep)
                             (set! buf (cons c buf))))))
        ((dep) (case c
                 ((#\space #\newline #\tab #\return) 
                  (begin
                    (set! state 'ws)
                    (arc:deps-set-deps! deps (list->string (reverse buf)))
                    (set! buf '())))
                 (else (set! buf (cons c buf)))))
        ((ws) (case c
                ((#\space #\newline #\tab #\return) 
                 (begin
                   'ignore))
                ((#\\) 'ignore)
                (else (begin
                        (set! state 'dep)
                        (set! buf (cons c buf))))))
        ))
    (close-input-port port)
    
    deps))


;; ----------------------------------------------------------------------
;; parsing dependency files as generated by makedeps
;; ----------------------------------------------------------------------

;; check whether /outfile/ needs to be redone from /source/.  /outfile/ is
;; compared to /source/ using the procedure /proc/ to determine
;; /source/'s dependencies.  /proc/ is a procedure taking two parameters
;; (/source/ and /outfile/) and returning dependencies (cf. constructed by
;; arc:deps-get-deps).  If /proc/ is not a procedure the following symbols
;; are understood:
;;
;; 'single: assume a single file dependency, i.e. /outfile/ only depends on
;;          /source/
;; 'list:   assume /source/ is a (string)list of source files.  /outfile/ 
;;          depends on all of them.
(define (arc:is-due? outfile source proc)
  (let ((deps (cond
               ((procedure? proc) (apply proc (list source outfile)))
               ((symbol? proc) (case proc
                                 ((single) (arc:is-due-single-file 
                                            source outfile))
                                 ((list)   (arc:is-due-list-of-files
                                            source outfile))
                                 (else (arc:throw 'programming-error
                                                  "arc:is-due?: Unknown symbol"))) )
               (else (arc:throw 'programming-error
                                "arc:is-due?: Expected either procedure or symbol") ))))
    (if (not (list? deps))
        ;; for some reason we didn't got a dependecy list. assume recompile
        #t
        ;; otherwise check if the object file needs recompilation.  this is
        ;; done generic.  probably once replace the modification time
        ;; method by a md5sum based method?
        (arc:mtime-file-changed? deps outfile))))


(define (arc:is-due-single-file srcfile outfile)
  (arc:deps-get-deps srcfile outfile 
                     (lambda (src dest)
                       (arc:deps-set-deps! (arc:make-deps dest)
                                           src))))

(define (arc:make-deps-for-srcfiles srcfiles outfile)
  (let ((deps (arc:make-deps outfile)))
    (for-each (lambda (src) 
                (arc:deps-set-deps! deps src) )
              srcfiles)
    deps))


(define (arc:deps-match-srcfiles? deps srcfiles)
  (if (= (arc:deps-number-of-dependencies deps) (length srcfiles))
      (let loop ((p srcfiles))
        (if (null? p)
            #t
            (if (arc:deps-is-in-deps? deps (car p))
                (loop (cdr p))
                #f)))
      #f))


(define (arc:is-due-list-of-files srcfiles outfile)
  (let ((deps (arc:deps-get-deps srcfiles outfile 
                                 (lambda (src dest)
                                   (arc:make-deps-for-srcfiles src dest))) ))
    ;; we must make sure that the dependencies object (which may have been
    ;; cached) is uptodate with srcfiles
    (if (arc:deps-match-srcfiles? deps srcfiles)
        deps
        (let ((newdeps (arc:make-deps-for-srcfiles srcfiles outfile)))
          (arc:deps-update-deps outfile newdeps)
          newdeps)) ))
    

;;Keep this comment at the end of the file 
;;Local variables:
;;mode: scheme
;;End:
